# Архитектура модуля биллинга для Nest.js

## 1. Введение

Этот документ описывает архитектуру модуля биллинга, спроектированного для работы как в составе монолитного приложения, так и в качестве независимого микросервиса. Основные цели архитектуры — модульность, слабая связанность с другими частями системы и управляемость через события.

## 2. Ключевые принципы

*   **Модульность:** Вся логика биллинга инкапсулирована внутри одного Nest.js модуля (`BillingModule`).
*   **Слабая связанность (Loose Coupling):** Модуль не зависит напрямую от других сервисов (например, `UsersService`). Взаимодействие происходит асинхронно через события.
*   **Событийно-ориентированный подход (Event-Driven):**
    *   **Входящие события:** Модуль биллинга реагирует на события, происходящие в других частях системы (например, `user.created`).
    *   **Исходящие события:** Модуль биллинга сам генерирует события о важных изменениях, на которые могут подписаться другие модули (например, `subscription.status.changed`).
*   **Независимость:** Модуль имеет собственную схему данных и не "ходит" в таблицы других доменов напрямую. Необходимые данные из других контекстов он получает через события и хранит у себя.

## 3. Основные сущности (Entities)

Это основные объекты, которыми оперирует модуль биллинга. Они будут представлены в виде моделей базы данных (например, с помощью TypeORM или Prisma).

*   **Customer (Клиент):** Локальная копия пользователя, необходимая для биллинга. Содержит `userId` (для связи с основной сущностью пользователя в монолите) и `customerId` из платежной системы (например, Stripe Customer ID).
*   **Plan/Tariff (Тарифный план):** Описание тарифа. Содержит название, описание, цену, валюту, интервал списания (месяц/год) и `planId` из платежной системы.
*   **Subscription (Подписка):** Главная сущность. Связывает клиента с тарифным планом. Содержит статус (`active`, `canceled`, `past_due`), даты начала/окончания, дату следующего платежа и `subscriptionId` из платежной системы.
*   **Invoice (Счет):** Информация о выставленном счете. Содержит сумму, статус (`paid`, `open`, `void`), дату создания и ссылку на PDF-файл счета в платежной системе.
*   **Payment (Платеж):** Информация о конкретной транзакции.
*   **Balance (Баланс):** Представляет баланс пользователя. Содержит `amountIn` и `amountOut` для реализации double-entry подхода.

## 3.1. Подход Double-Entry Accounting

Для обеспечения надежности и консистентности данных в биллинговой системе используется подход, аналогичный двойной записи в бухгалтерии.

*   **Balance Entity:** Вместо одного поля `balance` в модели пользователя, мы используем отдельную сущность `Balance` с двумя полями:
    *   `amountIn`: Сумма всех поступлений на счет пользователя.
    *   `amountOut`: Сумма всех списаний со счета пользователя.
    *   Текущий баланс является вычисляемым значением: `balance = amountIn - amountOut`.
*   **Transaction Entity:** Каждая транзакция также отражает этот подход и содержит поля:
    *   `amountIn`: Сумма зачисления.
    *   `amountOut`: Сумма списания.

Это обеспечивает полный аудиторский след и позволяет избежать проблем с состоянием гонки (race conditions) при одновременном обновлении баланса.

## 4. Структура модуля

Предлагается использовать принципы, схожие с Domain-Driven Design (DDD) и гексагональной архитектурой, для четкого разделения ответственности.

```
/billing
├── application/                # Слой приложения
│   ├── use-cases/              # Бизнес-логика (создать подписку, отменить подписку)
│   │   ├── create-subscription.use-case.ts
│   │   └── cancel-subscription.use-case.ts
│   └── listeners/                # Обработчики входящих событий
│       └── user-created.listener.ts
├── domain/                     # Слой домена (чистая бизнес-логика и сущности)
│   ├── entities/               # Классы сущностей (Subscription, Customer)
│   ├── events/                 # Определения исходящих событий
│   │   └── subscription-status-changed.event.ts
│   └── services/               # Доменные сервисы (например, логика расчета скидок)
├── infrastructure/             # Слой инфраструктуры (внешние зависимости)
│   ├── database/               # Репозитории, схемы БД
│   │   ├── repositories/
│   │   │   └── subscription.repository.ts
│   │   └── schemas/
│   │       └── subscription.schema.ts
│   └── payment/                  # Адаптер для платежного шлюза
│       ├── payment-gateway.interface.ts
│       └── stripe.adapter.ts
├── presentation/               # Слой представления (API)
│   └── billing.controller.ts   # Контроллер для управления биллингом (если нужен прямой доступ)
└── billing.module.ts           # Главный модуль
```

## 5. Взаимодействие через события

Используется встроенный в Nest.js модуль `EventEmitterModule`.

#### Входящие события (Listeners)

Модуль биллинга слушает события из других доменов:

*   **`user.created`**:
    *   **Данные:** `{ userId: string, email: string, name: string }`
    *   **Действие:** `UserCreatedListener` создает запись `Customer` в БД биллинга и соответствующего клиента в Stripe, сохраняя `customerId`.

#### Исходящие события (Emitters)

Модуль биллинга генерирует события, информируя остальную систему:

*   **`subscription.status.changed`**:
    *   **Данные:** `{ userId: string, oldStatus: string, newStatus: string, plan: string }`
    *   **Действие:** Генерируется, когда подписка активируется, отменяется или становится просроченной. Другие модули (например, модуль фичей) могут слушать это событие, чтобы предоставить или ограничить доступ к функционалу.
*   **`invoice.payment.succeeded`**:
    *   **Данные:** `{ userId: string, amount: number, invoiceId: string }`
    *   **Действие:** Информирует о успешном платеже. Может использоваться для аналитики или отправки уведомлений.

## 6. Интеграция с платежными системами

Чтобы не зависеть от конкретного провайдера (Stripe), создается абстракция.

1.  **Интерфейс `PaymentGateway`**:
    Определяет методы, которые должна реализовывать любая платежная система:
    ```typescript
    interface PaymentGateway {
      createCustomer(email: string, name: string): Promise<{ customerId: string }>;
      createSubscription(customerId: string, planId: string): Promise<{ subscriptionId: string, status: string }>;
      cancelSubscription(subscriptionId: string): Promise<void>;
      // ... другие методы
    }
    ```
2.  **Адаптер `StripeAdapter`**:
    Конкретная реализация интерфейса `PaymentGateway`, инкапсулирующая логику работы со Stripe SDK.
3.  **Provider в `BillingModule`**:
    В модуле мы регистрируем `StripeAdapter` под токеном `PAYMENT_GATEWAY_TOKEN`. Все use-case'ы и сервисы используют этот токен, не зная о конкретной реализации.

## 7. Лучшие практики и дополнительные подходы

*   **Идемпотентность:** Все эндпоинты, принимающие вебхуки от платежных систем, должны быть идемпотентными. Это означает, что повторная обработка одного и того же запроса не приведет к дублированию операций (например, двойному списанию). Для этого можно использовать `Idempotency-Key` из заголовков запроса.

*   **Блокировки (Locking):** Для предотвращения состояния гонки при обновлении баланса пользователя, необходимо использовать механизмы блокировок:
    *   **Оптимистическая блокировка:** Добавление поля `version` в сущность `Balance`. При каждом обновлении версия инкрементируется. Если при попытке сохранения версия в базе данных отличается от ожидаемой, транзакция откатывается и может быть повторена.
    *   **Пессимистическая блокировка:** Блокировка на уровне строки в базе данных на время выполнения транзакции. Это более надежный, но и более медленный подход.

*   **Аудиторский след (Audit Trail):** Все изменения баланса и статусов подписок должны логироваться в отдельную, неизменяемую таблицу или сервис. Это критически важно для отладки, поддержки и финансовой отчетности.

*   **Асинхронная обработка:** Для долгих операций, таких как взаимодействие с внешними платежными шлюзами, следует использовать очереди сообщений (например, BullMQ или RabbitMQ). Это позволяет избежать блокировки основного потока приложения и улучшить отзывчивость системы.

## 8. Принятые решения

*   **Платежный шлюз:** Stripe.
*   **Модель биллинга:** Подписочная.
*   **Валюта:** Единая.

---

## TODO: План реализации

### Шаг 1: Настройка окружения и базового модуля

1.  `nest g module billing`
2.  `nest g controller billing/presentation/billing --no-spec`
3.  Установить зависимости: `npm install --save @nestjs/event-emitter stripe`
4.  Подключить `EventEmitterModule.forRoot()` в корневом `AppModule`.
5.  Создать структуру папок, как описано в разделе 4.

### Шаг 2: Определение доменных сущностей и событий

1.  Создать классы/интерфейсы для `Customer`, `Plan`, `Subscription`, `Invoice`, `Balance` в `billing/domain/entities/`.
2.  Определить классы для исходящих событий, например `SubscriptionStatusChangedEvent`, в `billing/domain/events/`.

### Шаг 3: Настройка инфраструктуры

1.  Определить схемы БД для сущностей (например, `subscription.schema.ts`).
2.  Создать интерфейс репозитория (`ISubscriptionRepository`) и его реализацию (`SubscriptionRepository`) для работы с БД.
3.  Определить интерфейс `PaymentGateway` в `billing/infrastructure/payment/payment-gateway.interface.ts`.
4.  Реализовать `StripeAdapter`, который имплементирует `PaymentGateway`.
5.  Зарегистрировать `StripeAdapter` как провайдер в `billing.module.ts`.

### Шаг 4: Реализация обработчиков входящих событий

1.  Создать `UserCreatedListener` в `billing/application/listeners/`.
2.  Внутри лисенера инжектировать `PaymentGateway` и репозиторий.
3.  Реализовать логику: при получении события `user.created` вызывать `paymentGateway.createCustomer()` и сохранять результат в БД биллинга.

### Шаг 5: Реализация Use Cases (бизнес-логики)

1.  Создать `CreateSubscriptionUseCase` в `billing/application/use-cases/`.
2.  Инжектировать в него `PaymentGateway` и репозитории.
3.  Реализовать метод `execute`, который принимает `userId` и `planId`, находит `customerId` и вызывает `paymentGateway.createSubscription()`.
4.  Сохранить результат в БД.
5.  Аналогично реализовать `CancelSubscriptionUseCase`.

### Шаг 6: Создание API (если необходимо)

1.  В `BillingController` создать эндпоинты для управления подписками.
2.  Например, `POST /subscriptions` для создания подписки и `DELETE /subscriptions/:id` для отмены.
3.  Методы контроллера должны вызывать соответствующие Use Cases.

### Шаг 7: Генерация исходящих событий

1.  В `CreateSubscriptionUseCase` и `CancelSubscriptionUseCase` после успешного выполнения операции инжектировать `EventEmitter2`.
2.  Вызывать `eventEmitter.emit('subscription.status.changed', new SubscriptionStatusChangedEvent(...))`.

### Шаг 8: Обработка Webhooks от Stripe

1.  Создать отдельный эндпоинт в `BillingController` (например, `POST /billing/webhooks/stripe`).
2.  Этот эндпоинт будет принимать вебхуки от Stripe (например, `invoice.payment_succeeded`, `customer.subscription.updated`).
3.  В обработчике вебхука парсить событие и вызывать соответствующие Use Cases или напрямую обновлять статусы в БД. **Важно:** этот механизм является ключевым для поддержания синхронизации данных с платежной системой.

### Шаг 9: Тестирование

1.  Написать unit-тесты для Use Cases, мокая зависимости (репозитории, `PaymentGateway`).
2.  Написать e2e-тесты для API эндпоинтов.
